<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
    <title>﻿Algorithm Complexity Assignment 1</title>
    <link type="text/css" rel="stylesheet" href="assets/css/github-markdown.css">
    <link type="text/css" rel="stylesheet" href="assets/css/pilcrow.css">
    <link type="text/css" rel="stylesheet" href="assets/css/hljs-github.min.css"/>
  </head>
  <body>
    <article class="markdown-body"><h2 id="algorithm-complexity-assignment-1"><a class="header-link" href="#algorithm-complexity-assignment-1"></a>﻿Algorithm Complexity Assignment 1</h2>
<ol class="list">
<li><p>An algorithm that has O(1) is a mix-master, and an algorithm that has O(2^n) is a hand operated whisk, mixing wet cement, that slowly hardens into a cement-cicle, with a whisk for a stick.</p>
</li>
<li><p>The best case scenario for binary search is that the item being searched for is the first item in the search index (ie: the first place you look). That&#39;s a complexity of 0(1) . In the case of binary search, where a 50-50 split is used to divide the list, that’s the middle item of the list.</p>
</li>
<li><p>The worst case scenario for binary search is a time complexity of O(logN), where the last element in a half is the item you&#39;re looking for.</p>
</li>
<li><p>The bounded case scenario for binary search is O(logN).</p>
</li>
<li><p>Graph of the source .csv data:
 <img src="../5_Source_Data_Graph.png" alt="See chart"></p>
</li>
<li><p>The limit of the function as it approaches infinity is infinity.</p>
</li>
<li><p>The complexity is O(N^2)</p>
</li>
<li><p>See function in main.cpp. It looks something like this:</p>
<pre class="hljs"><code> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">binaryWorstCase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
 <span class="hljs-keyword">return</span> <span class="hljs-built_in">log</span>(n);
 }</code></pre><ul class="list">
<li><p>I printed a list of values to a CSV file to make the graph, like this: </p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// how many lines to print</span>
  <span class="hljs-keyword">int</span> num = <span class="hljs-number">200</span>;

  <span class="hljs-comment">// open (or create, if it doesn't exist) the file that contains </span>
  <span class="hljs-comment">// the output data</span>
  ofstream myFile;
  myFile.open(<span class="hljs-string">"../src/output.csv"</span>);

  <span class="hljs-comment">// write the data to a file</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) {
      myFile &lt;&lt; i &lt;&lt; <span class="hljs-string">","</span>;
      myFile &lt;&lt; binaryWorstCase(i) &lt;&lt; <span class="hljs-built_in">endl</span>;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.8f\n"</span>, binaryWorstCase(i));
  }

  <span class="hljs-comment">// close the file</span>
  myFile.close();

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></li>
<li><p>The .csv file can be read in any graphing application (I used Excel, for expediency). </p>
</li>
</ul>
</li>
<li><p>The graph showing 200 iterations of the binary search worst cases: 
 <img src="../9_binary_worst_case_graph.png" alt="See Chart"></p>
</li>
<li><p>The Big-O of binary search is O(logN)</p>
</li>
<li><p>The big-Omega of binary search is O(1)</p>
</li>
<li><p>The big-theta of binary search is O(logN) </p>
</li>
</ol>
    </article>
  </body>
</html>
